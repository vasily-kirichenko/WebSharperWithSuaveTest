{
"version": 3,
"sourceRoot": "FSharpSource",
"sources": ["WebSharper.Web/ClientSideJson.fs", "WebSharper.Web/Control.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Json\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Core.Attributes\n\ntype OptionalFieldKind =\n    /// The field doesn't have type option<'T>\n    | NotOption = 0\n    /// The field has type option<'T>\n    | NormalOption = 1\n    /// The field has type option<'T> and is marked [<OptionalField>]\n    | MarkedOption = 2\n\n[<JavaScript>]\ntype Provider() =\n\n    static member Id () = id\n\n    abstract EncodeTuple : (unit -> obj -> obj)[] -> (unit -> obj[] -> obj)\n    default this.EncodeTuple encs =\n        fun () args ->\n            box (Array.map2 (fun f x -> f () x) encs args)\n\n    abstract EncodeDateTime : unit -> (unit -> System.DateTime -> obj)\n    default this.EncodeDateTime () =\n        fun () x ->\n            box (x.JS.ToISOString())\n\n    abstract EncodeList : (unit -> 'T -> obj) -> (unit -> list<'T> -> obj)\n    default this.EncodeList encEl =\n        fun () (l: list<'T>) ->\n            let a : obj[] = [||]\n            let encEl = encEl()\n            l |> List.iter (fun x -> a.JS.Push (encEl x) |> ignore)\n            box a\n\n    abstract EncodeRecord : obj -> (string * (unit -> obj -> obj) * OptionalFieldKind)[] -> (unit -> 'T -> obj)\n    default this.EncodeRecord _ fields =\n        fun () x ->\n            let o = New []\n            fields |> Array.iter (fun (name, enc, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    o?(name) <- enc () x?(name)\n                | OptionalFieldKind.NormalOption ->\n                    match x?(name) with\n                    | Some x -> o?(name) <- enc () x\n                    | None -> ()\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- enc () x?(name)\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    abstract EncodeUnion : obj -> string -> (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[] -> (unit -> 'T -> obj)\n    default this.EncodeUnion _ discr cases =\n        fun () x ->\n            if JS.TypeOf x ===. JS.Object then\n                let o = New []\n                let tag = x?(\"$\")\n                let tagName, fields = cases.[tag]\n                if JS.TypeOf discr = JS.Kind.String then o?(discr) <- tagName\n                fields |> Array.iter (fun (from, ``to``, enc, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let record = enc () (x?(\"$0\"))\n                        JS.ForEach record (fun f -> o?(f) <- record?(f); false)\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(``to``) <- enc () (x?(from))\n                        | OptionalFieldKind.NormalOption ->\n                            match x?(from) with\n                            | Some x -> o?(``to``) <- enc () x\n                            | None -> ()\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else box x // [<Constant>]\n\n    abstract EncodeArray : (unit -> 'T -> obj) -> (unit -> 'T[] -> obj)\n    default this.EncodeArray encEl =\n        fun () (a: 'T[]) ->\n            let encEl = encEl()\n            box (Array.map encEl a)\n\n    abstract EncodeSet : (unit -> 'T -> obj) -> (unit -> Set<'T> -> obj)\n    default this.EncodeSet encEl =\n        fun () (s: Set<'T>) ->\n            let a : obj[] = [||]\n            let encEl = encEl()\n            s |> Set.iter (fun x -> a.JS.Push (encEl x) |> ignore)\n            box a\n\n    abstract EncodeStringMap : (unit -> 'T -> obj) -> (unit -> Map<string, 'T> -> obj)\n    default this.EncodeStringMap encEl =\n        fun () (m: Map<string, 'T>) ->\n            let o = New []\n            let encEl = encEl()\n            m |> Map.iter (fun k v -> o?(k) <- encEl v)\n            o\n\n    abstract EncodeStringDictionary : (unit -> 'T -> obj) -> (unit -> Dictionary<string, 'T> -> obj)\n    default this.EncodeStringDictionary encEl =\n        fun () (d: Dictionary<string, 'T>) ->\n            let o = New []\n            let encEl = encEl()\n            for KeyValue(k, v) in d :> seq<_> do o?(k) <- encEl v\n            o\n\n    abstract DecodeTuple : (unit -> obj -> obj)[] -> (unit -> obj -> obj[])\n    default this.DecodeTuple decs =\n        As (this.EncodeTuple decs)\n\n    abstract DecodeDateTime : unit -> (unit -> obj -> System.DateTime)\n    default this.DecodeDateTime() =\n        fun () x ->\n            Date(x :?> string).Self\n\n    abstract DecodeList : (unit -> obj -> 'T) -> (unit -> obj -> list<'T>)\n    default this.DecodeList decEl =\n        fun () a ->\n            let decEl = decEl()\n            List.init (a :?> obj[]).Length (fun i -> decEl (a :?> obj[]).[i])\n\n    abstract DecodeSet : (unit -> obj -> 'T) -> (unit -> obj -> Set<'T>)\n    default this.DecodeSet (decEl: unit -> obj -> 'T) : (unit -> obj -> Set<'T>) =\n        fun () a ->\n            let decEl = decEl()\n            Set.ofArray(Array.map decEl (a :?> obj[]))\n\n    abstract DecodeRecord : obj -> (string * (unit -> obj -> obj) * OptionalFieldKind)[] -> (unit -> obj -> 'T)\n    default this.DecodeRecord t fields =\n        fun () (x: obj) ->\n        let o = if t ===. JS.Undefined then New [] else JS.New t\n        fields |> Array.iter (fun (name, dec, kind) ->\n            match kind with\n            | OptionalFieldKind.NotOption ->\n                o?(name) <- dec () x?(name)\n            | OptionalFieldKind.NormalOption ->\n                o?(name) <-\n                    if JS.HasOwnProperty x name\n                    then Some (dec () x?(name))\n                    else None\n            | OptionalFieldKind.MarkedOption ->\n                if JS.HasOwnProperty x name then\n                    o?(name) <- (dec () x?(name))\n            | _ -> failwith \"Invalid field option kind\")\n        o\n\n    abstract DecodeUnion : obj -> string -> (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[] -> (unit -> obj -> 'T)\n    default this.DecodeUnion t discr cases =\n        fun () (x: obj) ->\n            if JS.TypeOf x ===. JS.Object then\n                let o = if t ===. JS.Undefined then New [] else JS.New t\n                let tag =\n                    // [<NamedUnionCases(discr)>]\n                    if JS.TypeOf discr = JS.Kind.String then\n                        let tagName = x?(discr)\n                        cases |> Array.findIndex (fun (name, _) -> name = tagName)\n                    else // [<NamedUnionCases>]\n                        let r = ref JS.Undefined\n                        JS.ForEach discr (fun k ->\n                            if JS.HasOwnProperty x k then r := discr?(k); true else false)\n                        !r\n                o?(\"$\") <- tag\n                cases.[tag] |> snd |> Array.iter (fun (from, ``to``, dec, kind) ->\n                    match from with\n                    | null -> // inline record\n                        o?(\"$0\") <- dec () x\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(from) <- dec () (x?(``to``))\n                        | OptionalFieldKind.NormalOption ->\n                            o?(from) <-\n                                if JS.HasOwnProperty x ``to``\n                                then Some (dec () x?(``to``))\n                                else None\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else x :?> 'T // [<Constant>]\n\n    abstract DecodeArray : (unit -> obj -> 'T) -> (unit -> obj -> 'T[])\n    default this.DecodeArray decEl =\n        As (this.EncodeArray (As decEl))\n\n    abstract DecodeStringMap : (unit -> obj -> 'T) -> (unit -> obj -> Map<string, 'T>)\n    default this.DecodeStringMap decEl =\n        fun () (o: obj) ->\n            let m = ref Map.empty\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> m := Map.add k o?(k) !m; false)\n            !m\n\n    abstract DecodeStringDictionary : (unit -> obj -> 'T) -> (unit -> obj -> Dictionary<string, 'T>)\n    default this.DecodeStringDictionary (decEl: unit -> obj -> 'T) : (unit -> obj -> Dictionary<string, 'T>) =\n        fun () (o: obj) ->\n            let d = System.Collections.Generic.Dictionary()\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> d.[k] <- o?(k); false)\n            d\n\n[<JavaScript>]\nmodule private Internals =\n\n    let Provider = Provider()\n\ntype Provider with\n    [<JavaScript; Inline>]\n    static member Default = Internals.Provider\n\nmodule Macro =\n\n    module J = WebSharper.Core.JavaScript.Core\n    module M = WebSharper.Core.Macros\n    module Q = WebSharper.Core.Quotations\n    module R = WebSharper.Core.Reflection\n    module T = WebSharper.Core.Reflection.Type\n    module JI = WebSharper.Core.Json.Internal\n    type private FST = Microsoft.FSharp.Reflection.FSharpType\n    type private T = WebSharper.Core.Reflection.Type\n    type private BF = System.Reflection.BindingFlags\n\n    type Parameters =\n        {\n            Warn : string -> unit\n            Provider : J.Expression\n        }\n\n    [<AutoOpen>]\n    module private Internals =\n\n        let cString s = !~ (J.String s)\n        let inline cInt i = !~ (J.Integer (int64 i))\n        let cCall t m x = J.Call (t, cString m, x)\n        let cCallG l m x = cCall (J.Global l) m x\n        let cCallE m x = cCallG [\"WebSharper\"; \"Json\"; \"Encode\"] m x\n        let cCallD m x = cCallG [\"WebSharper\"; \"Json\"; \"Decode\"] m x\n        let (|T|) (t: R.TypeDefinition) = t.FullName\n        let invoke x isEnc n = cCall x ((if isEnc then \"Encode\" else \"Decode\") + n)\n\n        type EncodeResult = Choice<J.Expression, string>\n\n        let (>>=) (m as x: EncodeResult) (f: J.Expression -> EncodeResult) =\n            match m with\n            | Choice1Of2 e -> f e\n            | Choice2Of2 _ -> x\n        let ok x = Choice1Of2 x : EncodeResult\n        let fail x = Choice2Of2 x : EncodeResult\n\n        let flags = BF.Public ||| BF.NonPublic\n\n        module Funs =\n            let id = J.Global [\"WebSharper\"; \"Json\"; \"Provider\"; \"Id\"]\n\n        let getEncoding name isEnc param tr (t: T) =\n            let ctx = System.Collections.Generic.Dictionary()\n            let call = invoke param.Provider isEnc\n            let rec encode t =\n                match t with\n                | T.Array (t, 1) ->\n                    encode t >>= fun e ->\n                    ok (call \"Array\" [e])\n                | T.Array _ ->\n                    fail \"JSON serialization for multidimensional arrays is not supported.\"\n                | T.Concrete (T (\"Microsoft.FSharp.Core.Unit\"\n                                |\"System.Boolean\"\n                                |\"System.SByte\" | \"System.Byte\"\n                                |\"System.Int16\" | \"System.UInt16\"\n                                |\"System.Int32\" | \"System.UInt32\"\n                                |\"System.Int64\" | \"System.UInt64\"\n                                |\"System.Single\"| \"System.Double\"\n                                |\"System.Decimal\"\n                                |\"System.String\"\n                                |\"WebSharper.Core.Json+Encoded\"), []) ->\n                    ok Funs.id\n                | T.Concrete (T \"Microsoft.FSharp.Collections.FSharpList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"List\" [e])\n                | T.Concrete (T \"Microsoft.FSharp.Collections.FSharpSet`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Set\" [e])\n                | T.Concrete (T \"Microsoft.FSharp.Collections.FSharpMap`2\",\n                                [T.Concrete (T \"System.String\", []); t]) ->\n                    encode t >>= fun e -> \n                    ok (call \"StringMap\" [e])\n                | T.Concrete (T \"System.Collections.Generic.Dictionary`2\",\n                                [T.Concrete (T \"System.String\", []); t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"StringDictionary\" [e])\n                | T.Concrete (T n, ts) when n.StartsWith \"System.Tuple`\" ->\n                    ((fun es -> ok (call \"Tuple\" [J.NewArray es])), ts)\n                    ||> List.fold (fun k t ->\n                        fun es -> encode t >>= fun e -> k (e :: es))\n                    <| []\n                | T.Concrete (T \"System.DateTime\", []) ->\n                    ok (call \"DateTime\" [])\n                | T.Concrete (td, args) ->\n                    match ctx.TryGetValue td with\n                    | true, (id, _) -> ok (J.Var id)\n                    | false, _ ->\n                        let id = J.Id()\n                        ctx.[td] <- (id, !~J.Null)\n                        ((fun es ->\n                            encRecType t args es >>= fun e ->\n                            ctx.[td] <- (id, e)\n                            ok (J.Var id)\n                         ), args)\n                        ||> List.fold (fun k t es ->\n                            encode t >>= fun e -> k ((t, e) :: es))\n                        <| []\n                | T.Generic _ ->\n                    fail (name + \": Cannot de/serialize a generic value. You must call this function with a concrete type.\")\n            // Encode a type that might be recursively defined\n            and encRecType t targs args =\n                let tt = t.Load(false)\n                if FST.IsRecord(tt, flags) then\n                    let fields =\n                        FST.GetRecordFields(tt, flags)\n                        |> Array.map (fun f ->\n                            JI.GetName f, f, f.PropertyType)\n                    ((fun es ->\n                        let es, tts = List.unzip es\n                        // In order to construct a value of the right type, we need the\n                        // JS class corresponding to our type. To get it directly we would\n                        // need access to the metadata. For now the best way we have is\n                        // to compile a dummy object creation and extract the class from it.\n                        let tn =\n                            match tr (Q.NewRecord(t, List.map Q.DefaultValue tts)) with\n                            // Runtime.New(rec, {...})\n                            // Runtime.New(rec, Runtime.DeleteEmptyFields({...}, [...]))\n                            | J.Call (_, J.Constant (J.String \"New\"), [x; _]) -> x\n                            // Runtime.DeleteEmptyFields({...}, [...])\n                            | J.Call (_, J.Constant (J.String \"DeleteEmptyFields\"), _) \n                            // {...}\n                            | J.NewObject _ -> !~J.Undefined\n                            | x -> failwithf \"Invalid compiled record creation: %O\" x\n                        ok (call \"Record\" [tn; J.NewArray es])\n                        ), fields)\n                    ||> Array.fold (fun k (n, f, t) ->\n                        fun es ->\n                            if not (Array.isEmpty (f.GetCustomAttributes(typeof<DateTimeFormatAttribute>, false))) then\n                                param.Warn (sprintf \"Warning: This record field has a custom DateTime format: %s.%s. \\\n                                    Client-side JSON serialization does not support custom DateTime formatting. \\\n                                    This field will be serialized using ISO format.\"\n                                    f.DeclaringType.FullName f.Name)\n                            let t, optionKind =\n                                if t.IsGenericType && t.GetGenericTypeDefinition() = typedefof<option<_>> then\n                                    let kind =\n                                        if Array.isEmpty (f.GetCustomAttributes(typeof<OptionalFieldAttribute>, false)) then\n                                            OptionalFieldKind.NormalOption\n                                        else OptionalFieldKind.MarkedOption\n                                    t.GetGenericArguments().[0], cInt (int kind)\n                                else t, cInt (int OptionalFieldKind.NotOption)\n                            let tt = (T.FromType t)\n                            encode tt >>= fun e ->\n                            k ((J.NewArray [cString n; e; optionKind], tt) :: es))\n                    <| []\n                elif FST.IsUnion(tt, flags) then\n                    let discr, cases = JI.GetUnionEncoding tt\n                    ((0, fun cases ->\n                        let cases = J.NewArray cases\n                        let discr =\n                            match discr with\n                            | JI.NoField discrFields ->\n                                discrFields\n                                |> List.map (fun (name, id) -> name, cInt id)\n                                |> J.NewObject\n                            | JI.StandardField -> cString \"$\"\n                            | JI.NamedField n -> cString n\n                        // In order to construct a value of the right type, we need the\n                        // JS class corresponding to our type. To get it directly we would\n                        // need access to the metadata. For now the best way we have is\n                        // to compile a dummy object creation and extract the class from it.\n                        let tn =\n                            let c1 = FST.GetUnionCases(tt, flags).[0]\n                            let uc : Q.Concrete<R.UnionCase> =\n                                { Generics = targs\n                                  Entity = R.UnionCase.Create (R.TypeDefinition.FromType tt) c1.Name }\n                            let args =\n                                c1.GetFields()\n                                |> Array.map (fun f -> Q.DefaultValue (T.FromType f.PropertyType))\n                                |> List.ofArray\n                            match tr (Q.NewUnionCase(uc, args)) with\n                            // Runtime.New(union, {...})\n                            | J.Call (_, J.Constant (J.String \"New\"), [x; _]) -> x\n                            // {...}\n                            | J.NewObject _\n                            // [<Constant>]\n                            | J.Constant _ -> !~J.Undefined\n                            | x -> failwithf \"Invalid compiled union creation: %O\" x\n                        ok (call \"Union\" [tn; discr; cases])\n                        ), cases)\n                    ||> Array.fold (fun (i, k) case ->\n                        i + 1, fun es ->\n                            match case with\n                            | JI.Normal (caseName, argNames) ->\n                                ((0, fun argNames ->\n                                    let tag =\n                                        match discr with\n                                        | JI.StandardField -> cInt i\n                                        | _ -> cString caseName\n                                    k (J.NewArray [tag; J.NewArray argNames] :: es)\n                                    ), argNames)\n                                ||> Array.fold (fun (j, k) (argName, argT, argFlags) ->\n                                    if argFlags |> Array.exists (function JI.DateTimeFormat _ -> true) then\n                                        param.Warn (sprintf \"Warning: This union case field has a custom DateTime format: %s.%s [%s]. \\\n                                            Client-side JSON serialization does not support custom DateTime formatting. \\\n                                            This field will be serialized using ISO format.\"\n                                            tt.FullName caseName argName)\n                                    let argT, optionKind =\n                                        if argT.IsGenericType && argT.GetGenericTypeDefinition() = typedefof<option<_>> then\n                                            argT.GetGenericArguments().[0], cInt (int OptionalFieldKind.NormalOption)\n                                        else argT, cInt (int OptionalFieldKind.NotOption)\n                                    j + 1, fun es ->\n                                        encode (T.FromType argT) >>= fun e ->\n                                        k (J.NewArray [cString (\"$\" + string j); cString argName; e; optionKind] :: es))\n                                |> snd\n                                <| []\n                            | JI.InlineRecord(name, record) ->\n                                let tag =\n                                    match discr with\n                                    | JI.StandardField -> cInt i\n                                    | _ -> cString name\n                                encode (T.FromType record) >>= fun e ->\n                                k (J.NewArray [tag; J.NewArray [J.NewArray [!~J.Null; !~J.Null; e]]] :: es)\n                            | JI.Constant _ -> k (!~J.Null :: es)\n                    )\n                    |> snd\n                    <| []\n                else\n                    fail (name + \": Type not supported: \" + tt.FullName)\n            match encode t with\n            | Choice1Of2 x ->\n                match ctx.Count with\n                | 0 -> x\n                | 1 ->\n                    let (KeyValue(_, (id, e))) = Seq.head ctx\n                    J.Let(id, e, x)\n                | _ ->\n                    J.LetRecursive(\n                        [for KeyValue(_, (id, e)) in ctx do\n                            let xid = J.Id()\n                            yield xid, !~J.Null\n                            // function() { if (!xid) { xid = e() }; return xid; }\n                            yield id, J.Lambda(None, [],\n                                J.Sequential(\n                                    J.IfThenElse(\n                                        J.Unary(J.UnaryOperator.``!``, J.Var xid),\n                                        J.VarSet(xid, J.Application(e, [])),\n                                        !~J.Null),\n                                    J.Var xid))\n                            ],\n                        x)\n            | Choice2Of2 msg -> failwithf \"%A: %s\" t msg\n\n        let encodeLambda name param tr t =\n            J.Application(getEncoding name true param tr t, [])\n\n        let encode name param tr t arg =\n            J.Application(encodeLambda name param tr t, [arg])\n\n        let decodeLambda name param tr t =\n            J.Application(getEncoding name false param tr t, [])\n\n        let decode name param tr t arg =\n            J.Application(decodeLambda name param tr t, [arg])\n\n    type Parameters with\n\n        static member Default (tr : Q.Expression -> J.Expression) =\n            {\n                Warn = ignore\n                Provider =\n                    Q.PropertyGet(\n                        {\n                            Entity = typeof<Provider>.GetProperty(\"Default\", BF.Static ||| BF.Public) |> R.Property.Parse\n                            Generics = []\n                        },\n                        []\n                    )\n                    |> tr\n            }\n\n    let Encode param tr t arg =\n        // ENCODE()(arg)\n        encode \"Encode\" param tr t (tr arg)\n\n    let EncodeLambda param tr t =\n        // ENCODE()\n        encodeLambda \"EncodeLambda\" param tr t\n\n    let Serialize param tr t arg =\n        // JSON.stringify(ENCODE()(arg))\n        cCallG [\"JSON\"] \"stringify\" [encode \"Serialize\" param tr t (tr arg)]\n\n    let SerializeLambda param tr t =\n        let enc = J.Id()\n        let arg = J.Id()\n        // let enc = ENCODE() in fun arg -> JSON.stringify(enc(arg))\n        J.Let(enc, encodeLambda \"SerializeLambda\" param tr t,\n            J.Lambda(None, [arg],\n                cCallG [\"JSON\"] \"stringify\" [J.Application(J.Var enc, [J.Var arg])]))\n\n    let Decode param tr t arg =\n        // DECODE()(arg)\n        decode \"Decode\" param tr t (tr arg)\n\n    let DecodeLambda param tr t =\n        // DECODE()\n        decodeLambda \"DecodeLambda\" param tr t\n\n    let Deserialize param tr t arg =\n        // DECODE()(JSON.parse(arg))\n        decode \"Deserialize\" param tr t (cCallG [\"JSON\"] \"parse\" [tr arg])\n\n    let DeserializeLambda param tr t =\n        // let dec = DECODE() in fun arg -> dec(JSON.parse(arg))\n        let dec = J.Id()\n        let arg = J.Id()\n        J.Let(dec, decodeLambda \"DeserializeLambda\" param tr t,\n            J.Lambda(None, [arg],\n                J.Application(J.Var dec, [cCallG [\"JSON\"] \"parse\" [J.Var arg]])))\n\n    type SerializeMacro() =\n\n        static let rec last = function\n            | [x] -> x\n            | x :: l -> last l\n            | _ -> failwith \"\"\n\n        interface M.IMacro with\n            member this.Translate(q, tr) =\n                let param = Parameters.Default tr // TODO: change Warn when we implement warn in macros\n                match q with\n                | Q.CallModule({Generics = [t]; Entity = e}, args)\n                | Q.Call({Generics = [t]; Entity = e}, args) ->\n                    let f, provider =\n                        match e.Name with\n                        | \"Encode\" -> Encode, param.Provider\n                        | \"Decode\" -> Decode, param.Provider\n                        | \"Serialize\" -> Serialize, param.Provider\n                        | \"Deserialize\" -> Deserialize, param.Provider\n                        | \"EncodeWith\" -> Encode, tr (List.head args)\n                        | \"DecodeWith\" -> Decode, tr (List.head args)\n                        | \"SerializeWith\" -> Serialize, tr (List.head args)\n                        | \"DeserializeWith\" -> Deserialize, tr (List.head args)\n                        | _ -> failwith \"Invalid macro invocation\"\n                    let id = J.Id()\n                    J.Let(id, provider, f {param with Provider = J.Var id} tr t (last args))\n                | _ -> failwith \"Invalid macro invocation\"\n\nopen Macro\n\n/// Encodes an object in such a way that JSON stringification\n/// results in the same readable format as Sitelets.\n[<Macro(typeof<SerializeMacro>)>]\nlet Encode<'T> (x: 'T) = X<obj>\n\n/// Encodes an object in such a way that JSON stringification\n/// results in the same readable format as Sitelets.\n[<Macro(typeof<SerializeMacro>)>]\nlet EncodeWith<'T> (provider: Provider) (x: 'T) = X<obj>\n\n/// Serializes an object to JSON using the same readable format as Sitelets.\n/// For plain JSON stringification, see Json.Stringify.\n[<Macro(typeof<SerializeMacro>)>]\nlet Serialize<'T> (x: 'T) = X<string>\n\n/// Serializes an object to JSON using the same readable format as Sitelets.\n/// For plain JSON stringification, see Json.Stringify.\n[<Macro(typeof<SerializeMacro>)>]\nlet SerializeWith<'T> (provider: Provider) (x: 'T) = X<string>\n\n/// Decodes an object parsed from the same readable JSON format as Sitelets.\n[<Macro(typeof<SerializeMacro>)>]\nlet Decode<'T> (x: obj) = X<'T>\n\n/// Decodes an object parsed from the same readable JSON format as Sitelets.\n[<Macro(typeof<SerializeMacro>)>]\nlet DecodeWith<'T> (provider: Provider) (x: obj) = X<'T>\n\n/// Deserializes a JSON string using the same readable format as Sitelets.\n/// For plain JSON parsing, see Json.Parse.\n[<Macro(typeof<SerializeMacro>)>]\nlet Deserialize<'T> (x: string) = X<'T>\n\n/// Deserializes a JSON string using the same readable format as Sitelets.\n/// For plain JSON parsing, see Json.Parse.\n[<Macro(typeof<SerializeMacro>)>]\nlet DeserializeWith<'T> (provider: Provider) (x: string) = X<'T>\n\nlet (|Object|Array|Number|String|Boolean|Undefined|) (o: WebSharper.Core.Json.Encoded) =\n    match JS.TypeOf o with\n    | JS.Kind.Boolean -> Boolean (As<bool> o)\n    | JS.Kind.Number -> Number (As<float> o)\n    | JS.Kind.String -> String (As<string> o)\n    | JS.Kind.Undefined -> Undefined o\n    | JS.Kind.Function -> failwith \"\"\n    | JS.Kind.Object ->\n        if JS.InstanceOf o JS.Window?Array then\n            Array (As<WebSharper.JavaScript.Array<WebSharper.Core.Json.Encoded>> o)\n        else\n            Object (As<WebSharper.JavaScript.Object<WebSharper.Core.Json.Encoded>> o)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2015 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Web\n\nopen WebSharper\n\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.Reflection\nmodule P = WebSharper.Core.JavaScript.Packager\n\n/// A base class for defining custom ASP.NET controls. Inherit from this class,\n/// override the Body property and use the new class as a Server ASP.NET\n/// control in your application.\n[<AbstractClass>]\ntype Control() =\n    inherit System.Web.UI.Control()\n\n    static let gen = System.Random()\n    [<System.NonSerialized>]\n    let mutable id = System.String.Format(\"ws{0:x}\", gen.Next().ToString())\n\n    override this.ID\n        with get () = id\n        and set x = id <- x\n\n    override this.OnLoad _ =\n        this.ID <- ScriptManager.Find(base.Page).Register (Some id) this\n\n    interface INode with\n        member this.IsAttribute = false\n        member this.Write (meta, w) =\n            w.Write(\"\"\"<div id=\"{0}\"></div>\"\"\", this.ID)\n        member this.AttributeValue = None\n        member this.Name = None\n\n    abstract member Body : IControlBody\n    default this.Body = Unchecked.defaultof<_>\n\n    interface IControl with\n        member this.Body = this.Body\n        member this.Id = this.ID\n\n    interface IRequiresResources with\n        member this.Requires =\n            let t = this.GetType()\n            let t = if t.IsGenericType then t.GetGenericTypeDefinition() else t\n            [M.TypeNode (R.TypeDefinition.FromType t)] :> seq<_>\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n    override this.Render writer =\n        writer.WriteLine(\"<div id='{0}'></div>\", this.ID)\n\nopen WebSharper.JavaScript\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\n\n/// Implements a web control based on a quotation-wrapped top-level body.\n/// Use the function ClientSide to create an InlineControl.\ntype InlineControl<'T when 'T :> IControlBody>(elt: Expr<'T>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    let getLocation() =\n        let (|Val|_|) e : 't option =\n            match e with\n            | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n            | _ -> None\n        let l =\n            elt.CustomAttributes |> Seq.tryPick (function\n                | NewTuple [ Val \"DebugRange\";\n                             NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                    Some (sprintf \"%s: %i.%i-%i.%i\" file startLine startCol endLine endCol)\n                | _ -> None)\n        defaultArg l \"(no location)\"\n\n    static let ctrlReq = M.TypeNode (R.TypeDefinition.FromType typeof<InlineControl<IControlBody>>)\n\n    [<System.NonSerialized>]\n    let bodyAndReqs =\n        let declType, name, args, fReqs =\n            let elt =\n                match elt :> Expr with\n                | Coerce (e, _) -> e\n                | e -> e\n            match elt with\n            | PropertyGet(None, p, args) ->\n                let rp = R.Property.Parse p\n                rp.DeclaringType, rp.Name, args, [M.TypeNode rp.DeclaringType]\n            | Call(None, m, args) ->\n                let rm = R.Method.Parse m\n                rm.DeclaringType, rm.Name, args, [M.MethodNode rm; M.TypeNode rm.DeclaringType]\n            | e -> failwithf \"Wrong format for InlineControl at %s: expected global value or function access, got: %A\" (getLocation()) e\n        let args, argReqs =\n            args\n            |> List.mapi (fun i -> function\n                | Value (v, t) ->\n                    let v = match v with null -> WebSharper.Core.Json.Internal.MakeTypedNull t | _ -> v\n                    v, M.TypeNode (R.TypeDefinition.FromType t)\n                | _ -> failwithf \"Wrong format for InlineControl at %s: argument #%i is not a literal or a local variable\" (getLocation()) (i+1)\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        let reqs = ctrlReq :: fReqs @ argReqs :> seq<_>\n        args, (declType, name, reqs)\n\n    let args = fst bodyAndReqs\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Encode(meta, json) =\n            if funcName.Length = 0 then\n                let declType, name, _ = snd bodyAndReqs\n                match meta.GetAddress declType with\n                | None -> failwithf \"Error in InlineControl at %s: Couldn't find address for method\" (getLocation())\n                | Some a ->\n                    let rec mk acc (a: P.Address) =\n                        let acc = a.LocalName :: acc\n                        match a.Parent with\n                        | None -> Array.ofList acc\n                        | Some p -> mk acc p\n                    funcName <- mk [name] a\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n        member this.Requires =\n            let _, _, reqs = snd bodyAndReqs\n            reqs\n\nnamespace WebSharper\n\n[<AutoOpen>]\nmodule WebExtensions =\n\n    open Microsoft.FSharp.Quotations\n\n    /// Embed the given client-side control body in a server-side control.\n    /// The client-side control body must be either a module-bound or static value,\n    /// or a call to a module-bound function or static method, and all arguments\n    /// must be either literals or references to local variables.\n    let ClientSide (e: Expr<#IControlBody>) =\n        new WebSharper.Web.InlineControl<_>(e)\n"],
"names": ["Provider", "decEl", "x", "List", "Arrays", "a", "i", "t", "tupledArg", "Unchecked", "kind", "o", "name", "dec", "Operators", "action", "fields", "FSharpSet", "Dictionary", "JSModule", "d", "k", "FSharpMap", "m", "decs", "discr", "tagName", "predicate", "cases", "r", "tag", "tuple", "from", "to", "encEl", "Seq", "l", "enc", "matchValue", "s", "Enumerator", "enumerator", "forLoopVar", "activePatternResult", "v", "MapModule", "f", "encs", "args", "patternInput", "record", "Internals", "obj", "field"],
"mappings": "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"
}
